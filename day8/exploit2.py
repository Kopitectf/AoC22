def transfer(arr):
  tmp_arr = []
  tmp_arr.extend(arr)
  return tmp_arr

def get_arr():
  main_arr = []
  line_arr= []
  with open ("input.txt", "r") as input:
      Lines = input.readlines()
      for line in Lines:
        for ch in line:
          if ch != '\n':
            line_arr.append(ch)
        main_arr.append(transfer(line_arr))
        line_arr.clear()
  return main_arr

def check_direction(matrix, row, col, check_val, direction):
  viewing_distance = 0
  if direction == 'up':
    for tree in range(row-1,-1, -1):
      check_up = matrix[tree][col]
      if check_up >= check_val:
        viewing_distance += 1
        return viewing_distance
      else:
        viewing_distance += 1
  elif direction == 'down':
    for tree in range(row+1,len(matrix)):
      check_down = matrix[tree][col]
      if check_down >= check_val:
        viewing_distance += 1
        return viewing_distance
      else:
        viewing_distance += 1
  elif direction == 'left':
    for tree in range(col-1, -1, -1):
      check_left = matrix[row][tree]
      if check_left >= check_val:
        viewing_distance += 1
        return viewing_distance
      else:
        viewing_distance += 1
  else:
    for tree in range(col+1,len(matrix[0])):
      check_right = matrix[row][tree]
      if check_right >= check_val:
        viewing_distance += 1
        return viewing_distance
      else:
        viewing_distance += 1
  return viewing_distance

def get_viewing_distance(matrix, row, col):
  result = 0
  #get edge cases
  if row-1 < 0 or row+2 > len(matrix) or col-1 < 0 or col+2 > len(matrix[0]):
    result = 0
  else:
    value = matrix[row][col]
    up_val = check_direction(matrix, row, col, value, 'up')
    down_val = check_direction(matrix, row, col, value, 'down')
    left_val = check_direction(matrix, row, col, value, 'left')
    right_val = check_direction(matrix, row, col, value, 'right')
    result = up_val * down_val * left_val * right_val
  return result

def exploit():  
  matrix = get_arr()
  num_row = len(matrix)
  num_col = len(matrix[0])
  max_dist = 0
  for row in range(num_row):
    for col in range(num_col):
      dist = get_viewing_distance(matrix, row, col)
      if dist > max_dist:
        max_dist = dist
  print(max_dist)
  
if __name__ == "__main__":
   exploit()
