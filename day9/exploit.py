import time

class head:
  vert = 0
  hor = 0
  move_list = [[0,0]]

class tail:
  vert = 0
  hor = 0
  move_list = [[0,0]]

def touching(head, tail):
  #print(f" touching vals  {abs(head.hor)-abs(tail.hor)} {abs(head.vert)-abs(tail.vert)}")

  if abs(abs(head.vert)-abs(tail.vert)) > 1:
    return False
  if abs(abs(head.hor)-abs(tail.hor)) > 1:
    return False
  
  return True

def check_move_diagonal(head, tail):
  #if 2 directions are not equal we need to move diagonal
  num_diff = 0
  if head.vert != tail.vert:
    num_diff +=1
  if head.hor != tail.hor:
    num_diff +=1

  if num_diff >= 2:
    return True
  else:
    return False

def move(val, direction):
  if direction == 'U':
    val.vert -= 1
  elif direction == 'D':
    val.vert += 1
  elif direction == 'L':
    val.hor += 1
  else:
    val.hor -= 1
  list = (val.hor, val.vert)
  val.move_list.append(list)

def move_diag(val, direction):
  if direction == 'U':
    val.vert -= 1
  elif direction == 'D':
    val.vert += 1
  elif direction == 'L':
    val.hor += 1
  else:
    val.hor -= 1
  list = [val.hor, val.vert]
  val.move_list.pop()
  val.move_list.append(list)

def exploit():
  head_val = head()
  tail_val = tail()
  last_direction = ""

  with open ("input.txt", "r") as input:
      Lines = input.readlines()
      for line in Lines:
        commands = line.split()
        direction = commands[0]
        distance = int(commands[1])

        for step in range(distance):
          move(head_val, direction)
          if not touching(head_val, tail_val):
            move(tail_val, direction)
            if check_move_diagonal(head_val, tail_val):
              move_diag(tail_val, last_direction)
        last_direction = direction
  
  #print(tail_val.move_list)
  print(len(tail_val.move_list))
  res = []
  [res.append(x) for x in tail_val.move_list if x not in res]
  print(len(res))


if __name__ == "__main__":
   exploit()